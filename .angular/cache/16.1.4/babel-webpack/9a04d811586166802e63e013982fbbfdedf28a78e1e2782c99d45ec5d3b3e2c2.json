{"ast":null,"code":"import { of } from 'rxjs';\nimport { HttpHeaders } from '@angular/common/http';\nimport { catchError, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./message.service\";\nexport class DishService {\n  constructor(http, messageService) {\n    this.http = http;\n    this.messageService = messageService;\n    this.dishesUrl = 'api/dishes'; // URL to web api\n    this.httpOptions = {\n      headers: new HttpHeaders({\n        'Content-Type': 'application/json'\n      })\n    };\n  }\n  /** GET heroes from the server */\n  getDishes() {\n    return this.http.get(this.dishesUrl).pipe(tap(_ => this.log('fetched dishes')), catchError(this.handleError('getDishes', [])));\n  }\n  /** GET hero by id. Will 404 if id not found */\n  getDish(id) {\n    const url = `${this.dishesUrl}/${id}`;\n    return this.http.get(url).pipe(tap(_ => this.log(`fetched dish id=${id}`)), catchError(this.handleError(`getDish id=${id}`)));\n  }\n  /** Log a HeroService message with the MessageService */\n  log(message) {\n    this.messageService.add(`DishService: ${message}`);\n  }\n  /**\n   * Handle Http operation that failed.\n   * Let the app continue.\n   *\n   * @param operation - name of the operation that failed\n   * @param result - optional value to return as the observable result\n   */\n  handleError(operation = 'operation', result) {\n    return error => {\n      // TODO: send the error to remote logging infrastructure\n      console.error(error); // log to console instead\n      // TODO: better job of transforming error for user consumption\n      this.log(`${operation} failed: ${error.message}`);\n      // Let the app keep running by returning an empty result.\n      return of(result);\n    };\n  }\n  /** PUT: update the hero on the server */\n  updateDish(dish) {\n    return this.http.put(this.dishesUrl, dish, this.httpOptions).pipe(tap(_ => this.log(`updated dish=${dish.name}`)), catchError(this.handleError('updateDish')));\n  }\n  /** POST: add a new hero to the server */\n  addDish(newDish) {\n    return this.http.post(this.dishesUrl, newDish, this.httpOptions).pipe(tap(newDish => this.log(`added dish w/ name=${newDish.name}`)), catchError(this.handleError('addDish')));\n  }\n  /** DELETE: delete the hero from the server */\n  deleteDish(id) {\n    const url = `${this.dishesUrl}/${id}`;\n    return this.http.delete(url, this.httpOptions).pipe(tap(_ => this.log(`deleted dish id=${id}`)), catchError(this.handleError('deleteDish')));\n  }\n  /* GET heroes whose name contains search term */\n  searchDishes(term) {\n    if (!term.trim()) {\n      // if not search term, return empty hero array.\n      return of([]);\n    }\n    return this.http.get(`${this.dishesUrl}/?name=${term}`).pipe(tap(x => x.length ? this.log(`found dishes matching \"${term}\"`) : this.log(`no dishes matching \"${term}\"`)), catchError(this.handleError('searchDishes', [])));\n  }\n}\nDishService.ɵfac = function DishService_Factory(t) {\n  return new (t || DishService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.MessageService));\n};\nDishService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: DishService,\n  factory: DishService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["of","HttpHeaders","catchError","tap","DishService","constructor","http","messageService","dishesUrl","httpOptions","headers","getDishes","get","pipe","_","log","handleError","getDish","id","url","message","add","operation","result","error","console","updateDish","dish","put","name","addDish","newDish","post","deleteDish","delete","searchDishes","term","trim","x","length","i0","ɵɵinject","i1","HttpClient","i2","MessageService","factory","ɵfac","providedIn"],"sources":["/Users/daram/Downloads/TourOfCaspian/src/app/dish.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\nimport { Observable, of } from 'rxjs';\n\nimport { Dish } from './dish';\nimport { MessageService } from './message.service';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { catchError, map, tap } from 'rxjs/operators';\n\n@Injectable({ providedIn: 'root' })\nexport class DishService {\n  private dishesUrl = 'api/dishes';  // URL to web api\n\n  constructor(\n    private http: HttpClient,\n    private messageService: MessageService) { }\n\n  /** GET heroes from the server */\n  getDishes(): Observable<Dish[]> {\n    return this.http.get<Dish[]>(this.dishesUrl)\n      .pipe(\n        tap(_ => this.log('fetched dishes')),\n        catchError(this.handleError<Dish[]>('getDishes', []))\n      );\n  }\n\n  /** GET hero by id. Will 404 if id not found */\n  getDish(id: number): Observable<Dish> {\n    const url = `${this.dishesUrl}/${id}`;\n    return this.http.get<Dish>(url).pipe(\n      tap(_ => this.log(`fetched dish id=${id}`)),\n      catchError(this.handleError<Dish>(`getDish id=${id}`))\n    );\n  }\n  /** Log a HeroService message with the MessageService */\n  private log(message: string) {\n    this.messageService.add(`DishService: ${message}`);\n  }\n  /**\n   * Handle Http operation that failed.\n   * Let the app continue.\n   *\n   * @param operation - name of the operation that failed\n   * @param result - optional value to return as the observable result\n   */\n  private handleError<T>(operation = 'operation', result?: T) {\n    return (error: any): Observable<T> => {\n\n      // TODO: send the error to remote logging infrastructure\n      console.error(error); // log to console instead\n\n      // TODO: better job of transforming error for user consumption\n      this.log(`${operation} failed: ${error.message}`);\n\n      // Let the app keep running by returning an empty result.\n      return of(result as T);\n    };\n  }\n  /** PUT: update the hero on the server */\n  updateDish(dish: Dish): Observable<any> {\n    return this.http.put(this.dishesUrl, dish, this.httpOptions).pipe(\n      tap(_ => this.log(`updated dish=${dish.name}`)),\n      catchError(this.handleError<any>('updateDish'))\n    );\n  }\n  httpOptions = {\n    headers: new HttpHeaders({ 'Content-Type': 'application/json' })\n  };\n  /** POST: add a new hero to the server */\n  addDish(newDish: Dish): Observable<Dish> {\n    return this.http.post<Dish>(this.dishesUrl, newDish, this.httpOptions).pipe(\n      tap((newDish: Dish) => this.log(`added dish w/ name=${newDish.name}`)),\n      catchError(this.handleError<Dish>('addDish'))\n    );\n  }\n  /** DELETE: delete the hero from the server */\n  deleteDish(id: number): Observable<Dish> {\n    const url = `${this.dishesUrl}/${id}`;\n\n    return this.http.delete<Dish>(url, this.httpOptions).pipe(\n      tap(_ => this.log(`deleted dish id=${id}`)),\n      catchError(this.handleError<Dish>('deleteDish'))\n    );\n  }\n  /* GET heroes whose name contains search term */\n  searchDishes(term: string): Observable<Dish[]> {\n    if (!term.trim()) {\n      // if not search term, return empty hero array.\n      return of([]);\n    }\n    return this.http.get<Dish[]>(`${this.dishesUrl}/?name=${term}`).pipe(\n      tap(x => x.length ?\n        this.log(`found dishes matching \"${term}\"`) :\n        this.log(`no dishes matching \"${term}\"`)),\n      catchError(this.handleError<Dish[]>('searchDishes', []))\n    );\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}